МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ

--------------------------------------------------------------------

ДОКУМЕНТАЦИЯ СЕРВЕРНОЙ ЧАСТИ ПРИЛОЖЕНИЯ 
ДЛЯ ОБМЕНА ВИЗУАЛЬНЫМ КОНТЕНТОМ
(По типу Pinterest)

Пояснительная записка к выпускной квалификационной работе

--------------------------------------------------------------------

СОДЕРЖАНИЕ

ВВЕДЕНИЕ............................................................................................3

1 ОБЩЕЕ ОПИСАНИЕ ПРОГРАММНОЙ СИСТЕМЫ...............................4
  1.1 Назначение и область применения..................................................4
  1.2 Функциональные возможности......................................................5
  1.3 Архитектура приложения.............................................................7

2 ТЕХНОЛОГИЧЕСКИЙ СТЕК..............................................................10
  2.1 Базовые технологии...................................................................10
  2.2 Система управления базами данных..............................................13
  2.3 Фреймворки и библиотеки...........................................................15
  2.4 Инструменты обеспечения безопасности........................................19
  2.5 Инструменты для работы с изображениями.....................................22
  2.6 Технологии асинхронного взаимодействия.....................................24
  2.7 Средства мониторинга и оптимизации...........................................26

3 СТРУКТУРА ПРОГРАММНОГО КОМПЛЕКСА......................................29
  3.1 Модульная организация серверной части.......................................29
  3.2 Модели данных.........................................................................31
  3.3 Контроллеры и API....................................................................41
  3.4 Сервисный слой........................................................................56
  3.5 Слой доступа к данным..............................................................67
  3.6 Конфигурации приложения..........................................................70

4 ДЕТАЛЬНОЕ ОПИСАНИЕ ФУНКЦИОНАЛЬНЫХ ВОЗМОЖНОСТЕЙ.............79
  4.1 Подсистема аутентификации и авторизации....................................79
  4.2 Подсистема управления пользовательскими профилями.......................91
  4.3 Подсистема управления контентом..............................................100
  4.4 Подсистема социального взаимодействия......................................116
  4.5 Подсистема уведомлений..........................................................128
  4.6 Подсистема поиска и рекомендаций.............................................140
  4.7 Геолокационные возможности....................................................152
  4.8 Подсистема управления файлами................................................159
  4.9 Административные функции.......................................................169

5 ТЕХНИЧЕСКИЕ ОСОБЕННОСТИ РЕАЛИЗАЦИИ....................................177
  5.1 RESTful API архитектура.........................................................177
  5.2 Механизмы пагинации и управления выборкой данных........................180
  5.3 Система валидации данных.......................................................183
  5.4 Документирование API.............................................................186
  5.5 Подсистема логирования..........................................................189
  5.6 Механизмы обработки ошибок.....................................................192
  5.7 Асинхронная обработка задач....................................................195
  5.8 Стратегии кеширования...........................................................198
  5.9 Мониторинг производительности.................................................201
  5.10 Механизмы ограничения нагрузки..............................................204

ЗАКЛЮЧЕНИЕ.................................................................................207

СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ............................................210

ПРИЛОЖЕНИЕ А. Примеры API запросов и ответов................................213

ПРИЛОЖЕНИЕ Б. Схема базы данных.................................................220

--------------------------------------------------------------------

ВВЕДЕНИЕ

В современном мире визуальный контент является одним из основных способов коммуникации и обмена информацией. Популярность социальных сетей и платформ для обмена медиа-контентом продолжает расти, создавая потребность в системах, позволяющих пользователям не только делиться изображениями, но и организовывать их в тематические коллекции, находить вдохновение и идеи для творчества, а также взаимодействовать с другими пользователями на основе общих интересов.

Данная пояснительная записка посвящена разработке серверной части приложения для обмена визуальным контентом, аналогичного по функциональности платформе Pinterest. Разработанный программный комплекс представляет собой полноценный бэкенд-сервер, реализующий все необходимые функции для хранения, обработки и организации изображений, социального взаимодействия между пользователями, а также обеспечения безопасности и оптимальной производительности системы.

Цель работы - создание масштабируемого, высокопроизводительного и безопасного серверного приложения с применением современных технологий и архитектурных решений. Серверная часть спроектирована в соответствии с принципами REST архитектуры, что обеспечивает гибкость и возможность интеграции с различными клиентскими приложениями - веб-интерфейсами, мобильными приложениями и настольными клиентами.

В процессе разработки были решены следующие задачи:
- проектирование и реализация архитектуры приложения;
- разработка моделей данных и схемы базы данных;
- реализация бизнес-логики приложения;
- обеспечение безопасности данных и аутентификации пользователей;
- интеграция с внешними сервисами для расширения функциональности;
- оптимизация производительности и масштабируемости системы;
- документирование программного интерфейса (API).

Актуальность работы обусловлена растущим спросом на приложения для обмена визуальным контентом и необходимостью создания современных, высокопроизводительных решений, способных обрабатывать большие объемы данных и обеспечивать бесперебойную работу при высоких нагрузках.

Практическая значимость разработки заключается в создании полноценного серверного приложения, готового к интеграции с клиентскими приложениями и дальнейшему расширению функциональности. Реализованные технические решения могут быть использованы в других проектах, связанных с обработкой медиа-контента и социальным взаимодействием пользователей.

--------------------------------------------------------------------

1 ОБЩЕЕ ОПИСАНИЕ ПРОГРАММНОЙ СИСТЕМЫ

1.1 Назначение и область применения

Разработанная программная система представляет собой серверную часть приложения для обмена визуальным контентом, предназначенную для хранения, обработки и организации изображений, а также обеспечения социального взаимодействия между пользователями. Система разработана по принципу платформы Pinterest, что определяет её основную функциональность и особенности архитектуры.

Основное назначение системы - обеспечение инфраструктуры для:
- хранения и управления пользовательскими учетными записями;
- загрузки, обработки и хранения изображений (пинов);
- организации изображений в тематические коллекции (доски);
- социального взаимодействия между пользователями (подписки, комментарии, лайки);
- поиска и рекомендации релевантного контента;
- уведомления пользователей о различных событиях в системе.

Область применения разработанной системы достаточно широка и включает в себя:
- социальные платформы для любителей визуального искусства;
- сервисы для сбора и организации идей и вдохновения;
- платформы для дизайнеров, архитекторов, фотографов и других представителей творческих профессий;
- инструменты для планирования мероприятий и проектов;
- системы обмена референсами в профессиональных сообществах;
- образовательные ресурсы с визуальным контентом.

Серверная часть разработана с учетом требований масштабируемости и может быть адаптирована для обслуживания как небольших сообществ, так и крупных платформ с миллионами пользователей. Модульная архитектура системы позволяет гибко настраивать её под конкретные потребности и интегрировать с различными клиентскими приложениями.

1.2 Функциональные возможности

Серверная часть приложения предоставляет широкий спектр функциональных возможностей, которые можно разделить на несколько категорий:

1.2.1 Управление пользователями
- Регистрация новых пользователей с подтверждением по электронной почте
- Аутентификация пользователей с использованием токенов JWT
- Восстановление доступа к учетной записи
- Управление пользовательскими профилями, включая персональные данные и аватары
- Система ролей и разграничение прав доступа (пользователи, модераторы, администраторы)
- Блокировка и разблокировка учетных записей
- Управление настройками конфиденциальности

1.2.2 Управление контентом
- Загрузка изображений различных форматов (JPEG, PNG, GIF, WebP и др.)
- Автоматическая обработка изображений (изменение размера, создание миниатюр)
- Извлечение и анализ метаданных изображений (EXIF данные)
- Создание и редактирование пинов с описаниями и тегами
- Организация пинов в коллекции (доски)
- Управление досками (создание, редактирование, удаление)
- Система тегов для категоризации контента
- Публикация постов с текстовым содержимым и изображениями

1.2.3 Социальное взаимодействие
- Подписка на пользователей и доски
- Оценка контента (лайки)
- Комментирование пинов и постов
- Создание и просмотр активности пользователей
- Шаринг контента с другими пользователями
- Отчеты о нарушениях и неприемлемом контенте
- Система обратной связи

1.2.4 Поиск и рекомендации
- Полнотекстовый поиск по названиям, описаниям и тегам
- Поиск по категориям и типам контента
- Поиск пользователей
- Фильтрация результатов поиска
- Персонализированные рекомендации на основе интересов пользователя
- Рекомендации по геолокации
- Трендовый контент и популярные пины

1.2.5 Уведомления
- Система уведомлений о действиях других пользователей (подписки, лайки, комментарии)
- Уведомления о новом контенте от подписанных пользователей
- Push-уведомления на мобильные устройства через Firebase Cloud Messaging
- Уведомления в реальном времени через Server-Sent Events (SSE)
- Управление настройками уведомлений

1.2.6 Геолокация
- Привязка контента к географическим координатам
- Поиск контента по местоположению
- Геокодирование и обратное геокодирование адресов
- Поиск пользователей по местоположению

1.2.7 Административные функции
- Модерация контента
- Управление пользователями и их правами
- Мониторинг активности и системных метрик
- Аналитика использования системы
- Управление категориями и тегами

1.2.8 Технические возможности
- API для взаимодействия с различными клиентскими приложениями
- Кеширование для оптимизации производительности
- Пагинация и курсор-пагинация для обработки больших наборов данных
- Валидация входящих данных
- Ограничение частоты запросов (rate limiting)
- Асинхронная обработка длительных операций
- Документирование API с использованием OpenAPI/Swagger
- Мониторинг производительности и сбор метрик

Все эти функциональные возможности реализованы с использованием современных технологий и архитектурных решений, что обеспечивает высокую производительность, масштабируемость и безопасность системы.

1.3 Архитектура приложения

Серверная часть приложения разработана на основе многоуровневой архитектуры, которая обеспечивает разделение ответственности между компонентами системы, упрощает поддержку и расширение функциональности. В архитектуре системы можно выделить следующие основные уровни:

1.3.1 Уровень представления (API)
На этом уровне определены контроллеры, которые обрабатывают HTTP-запросы от клиентских приложений, выполняют валидацию входных данных и передают их для обработки на уровень бизнес-логики. Контроллеры также формируют HTTP-ответы, которые отправляются обратно клиентам.

В приложении используется REST (Representational State Transfer) архитектурный стиль для организации API. Это обеспечивает единообразный интерфейс взаимодействия с системой, независимость от состояния и возможность кеширования результатов запросов.

Контроллеры разделены по функциональным областям:
- AuthController - аутентификация и управление токенами
- UserController - управление пользователями
- ProfileController - управление профилями
- PinController - операции с пинами
- BoardController - управление досками
- FollowController - подписки
- CommentController - комментарии
- NotificationController - уведомления
- SearchController - поисковые операции
- LocationController - геолокация
- FileController - загрузка и управление файлами
- AdminController - административные функции

1.3.2 Уровень бизнес-логики (сервисы)
Этот уровень содержит компоненты, реализующие бизнес-логику приложения. Сервисы абстрагированы от конкретных технологий доступа к данным и представления, что позволяет изменять эти технологии без изменения бизнес-логики.

Основные сервисы приложения:
- UserService - управление пользователями
- PinService - управление пинами
- BoardService - управление досками
- FollowService - логика подписок
- CommentService - управление комментариями
- NotificationService - логика уведомлений
- SearchService - поисковые операции
- LocationService - геолокационные функции
- FileStorageService - хранение и управление файлами
- EmailService - отправка электронных писем
- RefreshTokenService - управление токенами обновления

1.3.3 Уровень доступа к данным (репозитории)
Данный уровень обеспечивает взаимодействие с базой данных и другими источниками данных. Реализован с использованием Spring Data JPA, что упрощает разработку репозиториев для работы с объектами предметной области.

Каждая основная сущность приложения имеет соответствующий репозиторий:
- UserRepository
- PinRepository
- BoardRepository
- FollowRepository
- CommentRepository
- NotificationRepository
- LocationRepository
- RefreshTokenRepository

1.3.4 Уровень безопасности
Этот уровень отвечает за аутентификацию и авторизацию пользователей, а также за защиту от различных угроз безопасности. Реализован с использованием Spring Security и включает в себя:
- JWT-аутентификацию
- Фильтры безопасности
- Провайдеры аутентификации
- Обработчики исключений безопасности
- Конфигурацию CORS
- Защиту от CSRF-атак
- Ограничение частоты запросов

1.3.5 Уровень конфигурации
Содержит компоненты, отвечающие за конфигурацию различных аспектов приложения:
- SecurityConfig - конфигурация безопасности
- WebConfig - общая конфигурация веб-приложения
- DataSourceConfig - конфигурация источника данных
- CacheConfig - настройка кеширования
- RabbitMQConfig - конфигурация RabbitMQ
- FirebaseConfig - настройки Firebase для push-уведомлений
- WebSocketConfig - конфигурация WebSocket
- AsyncConfig - настройка асинхронных операций

1.3.6 Сквозные функциональности
К сквозным функциональностям, которые применяются на разных уровнях архитектуры, относятся:
- Логирование
- Обработка исключений
- Валидация данных
- Кеширование
- Транзакционность
- Мониторинг и сбор метрик

Архитектура приложения спроектирована в соответствии с принципами SOLID, что обеспечивает гибкость, расширяемость и поддерживаемость системы. Модульная организация и разделение ответственности между компонентами позволяют независимо развивать отдельные части системы и упрощают тестирование.

Для обеспечения масштабируемости и отказоустойчивости при высоких нагрузках предусмотрена возможность горизонтального масштабирования компонентов системы с использованием контейнеризации (Docker) и оркестрации (Docker Compose или Kubernetes). 2 ТЕХНОЛОГИЧЕСКИЙ СТЕК

2.1 Базовые технологии

В основе разработанной серверной части приложения лежат современные технологии, которые обеспечивают надежность, производительность и масштабируемость системы. Ключевой технологией разработки является Java 17, которая предоставляет богатые возможности для создания высоконагруженных серверных приложений.

2.1.1 Java 17

Выбор Java 17 в качестве основного языка программирования обусловлен следующими факторами:

- Долгосрочная поддержка (LTS) обеспечивает стабильность и безопасность
- Высокая производительность виртуальной машины (JVM)
- Богатая стандартная библиотека
- Сильная типизация, что уменьшает количество ошибок на этапе компиляции
- Автоматическое управление памятью (сборка мусора)
- Многопоточность и поддержка параллельного выполнения
- Масштабная экосистема библиотек и фреймворков

В разработке активно используются новые возможности Java 17, в том числе:
- Sealed классы для моделирования ограниченных иерархий
- Pattern matching для switch выражений
- Текстовые блоки для удобной работы с многострочным текстом
- Records для создания неизменяемых классов данных
- Усовершенствованные NullPointerException с более информативными сообщениями

2.1.2 Spring Boot 3.4.1

Основным фреймворком для разработки серверной части приложения является Spring Boot 3.4.1, который предоставляет комплексное решение для создания автономных, продакшн-готовых приложений на основе Spring Framework. Spring Boot существенно упрощает процесс разработки за счет автоматической конфигурации и устранения необходимости в ручной настройке множества компонентов.

Ключевые преимущества использования Spring Boot:

- Упрощенная конфигурация (принцип "convention over configuration")
- Встроенный сервер приложений (Tomcat, Jetty или Undertow)
- Автоконфигурация компонентов на основе зависимостей в проекте
- Готовые компоненты для решения типовых задач (security, data access, web и др.)
- Поддержка метрик и мониторинга через Spring Boot Actuator
- Удобная интеграция с внешними системами и сервисами
- Обширная документация и активное сообщество

В проекте используются следующие ключевые модули Spring Boot:

1. Spring Boot Starter Web
Предоставляет все необходимые зависимости для создания веб-приложения, включая встроенный Tomcat сервер, Spring MVC и другие компоненты для работы с HTTP.

2. Spring Boot Starter Data JPA
Обеспечивает интеграцию с JPA (Java Persistence API) для работы с реляционными базами данных. Включает Hibernate как реализацию JPA по умолчанию и упрощает создание репозиториев для доступа к данным.

3. Spring Boot Starter Security
Предоставляет функционал аутентификации и авторизации на основе Spring Security, что позволяет защитить приложение от распространенных уязвимостей веб-безопасности.

4. Spring Boot Starter Validation
Включает поддержку валидации на основе Bean Validation API (JSR 380), что позволяет декларативно определять правила валидации для объектов модели.

5. Spring Boot Starter Cache
Обеспечивает поддержку кеширования данных для оптимизации производительности приложения.

6. Spring Boot Starter WebSocket
Предоставляет функционал для реализации двусторонней коммуникации между клиентом и сервером через протокол WebSocket.

7. Spring Boot Starter Mail
Включает необходимые зависимости для отправки электронной почты из приложения.

8. Spring Boot Starter AMQP
Обеспечивает интеграцию с брокерами сообщений, поддерживающими протокол AMQP (Advanced Message Queuing Protocol), такими как RabbitMQ.

9. Spring Boot Starter AOP
Предоставляет возможности аспектно-ориентированного программирования для разделения сквозных функциональностей.

10. Spring Boot Starter Actuator
Обеспечивает мониторинг и управление приложением в среде продакшн, предоставляя различные метрики и возможности для проверки состояния системы.

2.1.3 Gradle

Для управления зависимостями и автоматизации сборки проекта используется Gradle с применением Kotlin DSL (build.gradle.kts). Gradle обеспечивает гибкое и эффективное управление жизненным циклом проекта, включая компиляцию, тестирование, упаковку и развертывание.

Основные преимущества Gradle:

- Декларативное описание зависимостей и процесса сборки
- Поддержка многомодульных проектов
- Инкрементальная компиляция для ускорения процесса сборки
- Развитая система управления зависимостями
- Гибкость настройки процесса сборки
- Встроенная поддержка репозиториев Maven и Ivy
- Расширяемость через систему плагинов

В проекте используются следующие плагины Gradle:

- org.springframework.boot - для создания исполняемых JAR-файлов
- io.spring.dependency-management - для управления версиями зависимостей Spring
- io.freefair.lombok - для интеграции с Lombok
- com.github.ben-manes.versions - для отслеживания обновлений зависимостей

2.1.4 Docker и контейнеризация

Для упрощения развертывания и обеспечения единообразия окружения разработки и продакшн используется Docker. Разработанное приложение упаковывается в Docker-контейнер, что обеспечивает следующие преимущества:

- Изоляция приложения и его зависимостей
- Единообразие окружения на всех стадиях жизненного цикла
- Простое масштабирование через репликацию контейнеров
- Эффективное использование ресурсов
- Быстрый запуск и остановка
- Декларативное описание инфраструктуры через Dockerfile

Для оркестрации контейнеров используется Docker Compose, который позволяет определить и запустить многоконтейнерные приложения. В docker-compose.yml файле определены следующие сервисы:

- Серверное приложение Spring Boot
- PostgreSQL база данных
- RabbitMQ для обработки асинхронных сообщений
- Серверы кеширования
- Средства мониторинга (Prometheus, Grafana)

2.2 Система управления базами данных

2.2.1 PostgreSQL

В качестве основной системы управления базами данных выбрана PostgreSQL - мощная объектно-реляционная СУБД с открытым исходным кодом. Выбор PostgreSQL обусловлен следующими факторами:

- Высокая надежность и устойчивость к сбоям
- Соответствие стандарту ANSI SQL
- Поддержка сложных типов данных и расширений
- Мощные возможности индексации, включая полнотекстовый поиск
- Поддержка JSON и других нереляционных типов данных
- Механизмы для обеспечения целостности данных
- Расширяемость через пользовательские функции и типы
- Хорошая производительность при высоких нагрузках
- Активное сообщество и регулярные обновления

В проекте используются следующие возможности PostgreSQL:

1. Полнотекстовый поиск (Full-Text Search) для эффективного поиска по текстовым полям (названия, описания, теги)

2. GIN индексы для ускорения полнотекстового поиска и запросов к массивам (например, теги)

3. JSONB тип данных для хранения структурированных данных с возможностью гибкого поиска

4. Геопространственное расширение PostGIS для работы с географическими данными и поиска по местоположению

5. Триггеры для автоматического обновления зависимых данных и поддержания целостности

6. Материализованные представления для оптимизации сложных запросов

7. Оконные функции для аналитических запросов и формирования рекомендаций

8. Хранимые процедуры для централизации бизнес-логики на уровне базы данных

Структура базы данных включает следующие основные таблицы:

- users - информация о пользователях
- pins - данные пинов (изображений)
- boards - доски (коллекции) пользователей
- pictures - метаданные изображений
- posts - публикации пользователей
- follows - подписки между пользователями
- comments - комментарии к пинам и постам
- likes - лайки пинов и постов
- notifications - уведомления пользователей
- locations - географические данные
- tags - теги для категоризации контента
- refresh_tokens - токены обновления для аутентификации
- verification_tokens - токены для верификации учетных записей
- fcm_tokens - токены для пуш-уведомлений

2.2.2 Миграции базы данных

Для управления схемой базы данных и обеспечения её эволюции без потери данных используется система миграций. Миграции определяют изменения схемы базы данных в виде SQL-скриптов или программного кода и выполняются автоматически при запуске приложения.

Преимущества использования миграций:

- Версионирование схемы базы данных
- Автоматическое применение изменений
- Воспроизводимость процесса создания и обновления базы данных
- Возможность отката к предыдущим версиям
- Поддержка различных окружений (разработка, тестирование, продакшн)

Миграции базы данных хранятся в директории resources/db/migration и именуются в соответствии с принятым форматом: V{версия}__{описание}.sql.

2.3 Фреймворки и библиотеки

В разработке серверной части приложения используется ряд дополнительных фреймворков и библиотек, которые расширяют функциональность основных технологий и упрощают решение типовых задач.

2.3.1 Lombok

Lombok является библиотекой для сокращения шаблонного кода в Java. Она автоматически генерирует геттеры, сеттеры, конструкторы, методы equals(), hashCode(), toString() и другие стандартные элементы кода на основе аннотаций.

Использование Lombok позволяет:

- Сократить объем кода и повысить его читаемость
- Уменьшить вероятность ошибок при написании стандартных методов
- Ускорить разработку
- Облегчить поддержку кода

В проекте используются следующие аннотации Lombok:

- @Data - генерирует геттеры, сеттеры, toString(), equals(), hashCode()
- @Builder - реализует шаблон проектирования Builder
- @NoArgsConstructor, @AllArgsConstructor - генерирует конструкторы
- @Slf4j - создает логгер SLF4J
- @EqualsAndHashCode - генерирует методы equals() и hashCode()
- @ToString - генерирует метод toString()

2.3.2 MapStruct

MapStruct - это генератор кода для преобразования между Java-бинами. Он позволяет автоматически генерировать код для преобразования между объектами различных классов, что особенно полезно для преобразования между сущностями JPA и DTO (Data Transfer Objects).

Преимущества использования MapStruct:

- Генерация кода во время компиляции (отсутствие рефлексии в рантайме)
- Высокая производительность преобразования
- Безопасность типов
- Удобная конфигурация через аннотации
- Поддержка сложных преобразований (вложенные объекты, коллекции)
- Расширяемость через пользовательские преобразователи

В проекте MapStruct используется для преобразования между:

- Сущностями базы данных и DTO для передачи данных клиентам
- DTO запросов и сущностями для сохранения данных
- Различными представлениями одних и тех же данных

2.3.3 JWT (JSON Web Tokens)

Для реализации аутентификации и авторизации пользователей используется технология JWT (JSON Web Tokens). JWT представляет собой компактный, самодостаточный способ безопасной передачи информации между сторонами в виде JSON-объекта.

Основные компоненты JWT:

- Header (заголовок) - содержит информацию о типе токена и используемом алгоритме подписи
- Payload (полезная нагрузка) - данные пользователя и метаданные токена
- Signature (подпись) - обеспечивает целостность и аутентичность токена

Преимущества использования JWT:

- Stateless аутентификация - сервер не хранит состояние сессии
- Масштабируемость - возможность распределения нагрузки между серверами
- Поддержка микросервисной архитектуры
- Передача данных пользователя в самом токене
- Безопасность - токены подписываются секретным ключом

В проекте JWT интегрирован с Spring Security и используется для:

- Аутентификации пользователей
- Авторизации доступа к защищенным ресурсам
- Передачи информации о пользователе между компонентами системы
- Реализации механизма refresh токенов для обновления доступа

Используемые библиотеки для работы с JWT:

- jjwt-api - основной API для работы с JWT
- jjwt-impl - реализация JWT
- jjwt-jackson - интеграция с Jackson для сериализации/десериализации

2.3.4 RabbitMQ и Spring AMQP

Для реализации асинхронной обработки задач и обмена сообщениями между компонентами системы используется RabbitMQ - брокер сообщений, реализующий протокол AMQP (Advanced Message Queuing Protocol). Интеграция с RabbitMQ осуществляется через Spring AMQP - расширение Spring Framework для работы с AMQP.

Основные преимущества использования RabbitMQ:

- Надежная доставка сообщений
- Масштабируемость и высокая производительность
- Гибкая маршрутизация сообщений
- Поддержка различных паттернов обмена сообщениями (publish-subscribe, routing, topics)
- Сохранение сообщений на диске для обеспечения надежности
- Кластеризация для повышения доступности

В проекте RabbitMQ используется для:

- Асинхронной обработки уведомлений
- Отправки электронных писем
- Выполнения длительных операций по обработке изображений
- Реализации системы событий для обновления данных в реальном времени
- Балансировки нагрузки при пиковых нагрузках

Основные компоненты RabbitMQ, используемые в проекте:

- Обменники (Exchanges) - точки входа сообщений
- Очереди (Queues) - буферы для хранения сообщений
- Привязки (Bindings) - связи между обменниками и очередями
- Маршрутные ключи (Routing Keys) - правила маршрутизации сообщений

2.3.5 Библиотеки для работы с изображениями

Для обработки и анализа изображений в проекте используются следующие библиотеки:

1. Metadata Extractor (com.drewnoakes:metadata-extractor)
Библиотека для извлечения метаданных из изображений различных форматов. Используется для получения EXIF данных, информации о цветовом профиле, размерах и других характеристиках изображений.

2. Thumbnailator (net.coobird:thumbnailator)
Библиотека для создания миниатюр изображений с различными параметрами (размер, качество, формат). Обеспечивает высокую производительность и качество обработки изображений.

3. WebP ImageIO (org.sejda.imageio:webp-imageio)
Расширение для Java ImageIO, добавляющее поддержку формата WebP - современного формата изображений от Google, который обеспечивает лучшее сжатие по сравнению с JPEG и PNG.

Эти библиотеки используются для:
- Создания миниатюр различных размеров для адаптивного отображения на разных устройствах
- Оптимизации изображений для уменьшения объема данных
- Извлечения метаданных для анализа и категоризации изображений
- Конвертации между различными форматами
- Применения фильтров и эффектов

2.4 Инструменты обеспечения безопасности

В разработанном серверном приложении большое внимание уделяется вопросам безопасности. Используется комплексный подход, включающий несколько уровней защиты и различные технологии для противодействия распространенным угрозам.

2.4.1 Spring Security

Основой системы безопасности является фреймворк Spring Security, который обеспечивает аутентификацию, авторизацию и защиту от различных атак. Spring Security интегрирован во все слои приложения и предоставляет следующие возможности:

- Конфигурация защищенных и публичных ресурсов
- Поддержка различных механизмов аутентификации (JWT, OAuth2)
- Ролевая модель авторизации
- Защита от CSRF (Cross-Site Request Forgery) атак
- Защита от XSS (Cross-Site Scripting) уязвимостей
- Настройка политик безопасности контента (CSP)
- Интеграция с хранилищами учетных данных
- Фильтрация HTTP-запросов для обеспечения безопасности

Конфигурация Spring Security определена в классе SecurityConfig и включает:
- Настройку защиты эндпоинтов API
- Определение политик CORS (Cross-Origin Resource Sharing)
- Конфигурацию JWT-аутентификации
- Настройку обработчиков ошибок аутентификации и авторизации
- Определение правил доступа на основе ролей пользователей

2.4.2 Валидация входных данных

Для защиты от атак, связанных с передачей некорректных или опасных данных, в приложении используется многоуровневая валидация входных данных:

1. Bean Validation (JSR 380) для декларативной валидации объектов:
   - @NotNull, @NotBlank - проверка на обязательность полей
   - @Size, @Min, @Max - проверка размеров и границ значений
   - @Email - валидация адресов электронной почты
   - @Pattern - проверка соответствия регулярным выражениям

2. Кастомные валидаторы для сложных правил проверки:
   - Валидация паролей на сложность
   - Проверка уникальности логинов и адресов электронной почты
   - Валидация формата и размера загружаемых изображений
   - Проверка содержимого на соответствие правилам сообщества

3. Фильтрация и санитизация HTML-контента для предотвращения XSS-атак:
   - Удаление опасных HTML-тегов и атрибутов
   - Экранирование специальных символов
   - Проверка URL на безопасность

4. Валидация на уровне контроллеров с использованием аннотации @Valid и BindingResult для обработки ошибок валидации.

2.4.3 Защита от нагрузок и атак

Для обеспечения устойчивости системы к различным видам атак и аномальным нагрузкам используются следующие механизмы:

1. Ограничение частоты запросов (Rate Limiting):
   - Использование библиотеки Bucket4j для реализации алгоритма "токенное ведро"
   - Настройка различных лимитов для разных типов запросов
   - Приоритизация запросов авторизованных пользователей
   - Возврат кода ответа 429 (Too Many Requests) при превышении лимита

2. Защита от подбора паролей:
   - Задержка между неудачными попытками входа
   - Временная блокировка учетных записей после определенного числа неудачных попыток
   - Использование CAPTCHA при подозрительной активности

3. Защита от атак на подмену идентификаторов сессий:
   - Использование безопасных куки (secure, httpOnly)
   - Регулярная ротация токенов
   - Валидация IP-адресов и User-Agent

4. Мониторинг и обнаружение аномалий:
   - Логирование подозрительной активности
   - Анализ шаблонов доступа
   - Уведомления администраторов о потенциальных атаках

2.4.4 Шифрование данных

Для защиты конфиденциальных данных в приложении используются различные методы шифрования:

1. Хранение паролей:
   - Использование алгоритма BCrypt для хеширования паролей
   - Добавление "соли" для защиты от радужных таблиц
   - Настройка оптимальной вычислительной сложности хеширования

2. Защита данных в базе данных:
   - Шифрование чувствительных полей на уровне приложения
   - Использование встроенных механизмов шифрования PostgreSQL для определенных колонок
   - Ограничение доступа к данным через ролевую модель СУБД

3. Защита данных при передаче:
   - Использование HTTPS для всех взаимодействий с API
   - Настройка безопасных параметров TLS
   - Регулярное обновление сертификатов

2.5 Инструменты для работы с изображениями

Работа с изображениями является ключевым аспектом разработанного приложения. Для эффективной обработки, хранения и доставки визуального контента используется комплекс специализированных инструментов и технологий.

2.5.1 Обработка изображений

Для обработки загруженных пользователями изображений используется многоэтапный процесс, включающий следующие операции:

1. Валидация изображений:
   - Проверка допустимых форматов (JPEG, PNG, GIF, WebP)
   - Проверка размеров и пропорций
   - Сканирование на вредоносный код
   - Проверка соответствия контента правилам сообщества

2. Создание миниатюр:
   - Генерация миниатюр различных размеров для адаптивной выдачи
   - Оптимизация под различные устройства и сценарии использования
   - Сохранение качества изображений при уменьшении размеров
   - Учет ориентации изображения из метаданных EXIF

3. Оптимизация:
   - Сжатие с оптимальным соотношением качества и размера
   - Удаление избыточных метаданных
   - Конвертация в оптимальные форматы (WebP для современных браузеров, JPEG для остальных)
   - Прогрессивная загрузка для крупных изображений

4. Специальная обработка:
   - Автоматическое определение и кадрирование ключевой области изображения
   - Применение фильтров и коррекции для улучшения визуального восприятия
   - Добавление водяных знаков для защиты авторских прав (опционально)
   - Автоматическое выделение доминантных цветов для создания цветовых схем

2.5.2 Хранение изображений

Для эффективного хранения изображений используется комбинированный подход:

1. Файловая система:
   - Организация директорий по датам и категориям
   - Использование уникальных имен файлов на основе UUID
   - Резервное копирование с помощью инкрементальных бэкапов
   - Распределение нагрузки через шардинг по разным физическим хранилищам

2. База данных:
   - Хранение метаданных изображений (размеры, формат, цветовая схема)
   - Связь с моделями данных (пины, пользователи)
   - Индексирование для быстрого поиска
   - Статистика использования и просмотров

3. Кеширование:
   - Кеширование часто запрашиваемых изображений в памяти
   - Использование CDN для географического распределения контента
   - Настройка заголовков кеширования для оптимизации повторных запросов
   - Инвалидация кеша при изменении изображений

2.5.3 Анализ изображений

Для улучшения пользовательского опыта и оптимизации работы с изображениями используются методы анализа визуального контента:

1. Извлечение метаданных:
   - Анализ EXIF данных для получения информации о камере, настройках съемки, геолокации
   - Определение размеров и пропорций изображения
   - Извлечение цветовой информации и профилей ICC
   - Анализ данных о дате создания и модификации

2. Цветовой анализ:
   - Определение доминантных цветов
   - Создание цветовых палитр
   - Классификация по цветовой гамме
   - Анализ контрастности и насыщенности

3. Семантический анализ:
   - Подготовка к интеграции с системами компьютерного зрения для автоматической категоризации
   - Распознавание объектов на изображениях
   - Определение стилей и типов изображений
   - Выявление неприемлемого контента

2.6 Технологии асинхронного взаимодействия

Для обеспечения высокой производительности и отзывчивости системы при высоких нагрузках в приложении используются различные технологии асинхронного взаимодействия.

2.6.1 RabbitMQ и обмен сообщениями

Основой системы асинхронной обработки является брокер сообщений RabbitMQ, который используется для:

1. Обработки уведомлений:
   - Публикация событий о действиях пользователей
   - Асинхронная доставка уведомлений подписчикам
   - Группировка и агрегация событий перед отправкой
   - Отложенные уведомления по расписанию

2. Отправки электронных писем:
   - Постановка в очередь задач на отправку писем
   - Повторные попытки при неудачной отправке
   - Приоритизация важных сообщений
   - Рассылка массовых уведомлений

3. Обработки изображений:
   - Очереди задач на генерацию миниатюр
   - Асинхронная оптимизация и анализ загруженных изображений
   - Распределение нагрузки между обработчиками
   - Отслеживание прогресса обработки

Основные очереди и обменники в RabbitMQ:
- notification.exchange - обменник для событий уведомлений
- email.queue - очередь для задач на отправку писем
- image.processing.queue - очередь задач обработки изображений
- event.tracking.queue - очередь для аналитических событий

2.6.2 Spring Async и многопоточная обработка

Для асинхронного выполнения операций внутри приложения используется механизм Spring Async:

- Аннотация @Async для обозначения методов, выполняемых асинхронно
- Настройка пулов потоков для различных типов задач
- Обработка результатов асинхронных операций с помощью CompletableFuture
- Обработка исключений в асинхронных методах

Типы задач, выполняемых асинхронно:
- Отправка уведомлений
- Логирование действий пользователей
- Обновление статистики и счетчиков
- Фоновая обработка данных

2.6.3 Server-Sent Events (SSE)

Для доставки уведомлений пользователям в реальном времени используется технология Server-Sent Events (SSE):

- Односторонний канал связи от сервера к клиенту
- Автоматическое восстановление соединения при разрывах
- Эффективное потребление ресурсов по сравнению с poll-запросами
- Возможность фильтрации событий на стороне сервера

2.7 Средства мониторинга и оптимизации

Для обеспечения стабильной работы и оптимальной производительности системы используются различные средства мониторинга и оптимизации.

2.7.1 Spring Boot Actuator и Micrometer

Spring Boot Actuator предоставляет готовые эндпоинты для мониторинга и управления приложением:

- /actuator/health - информация о состоянии приложения
- /actuator/metrics - метрики производительности
- /actuator/info - информация о приложении
- /actuator/env - информация об окружении
- /actuator/loggers - управление уровнями логирования

Micrometer используется как фасад для различных систем мониторинга:
- Сбор метрик производительности
- Мониторинг использования ресурсов
- Отслеживание времени выполнения запросов
- Сбор данных об ошибках и исключениях

2.7.2 Кеширование с Caffeine

Для оптимизации производительности и уменьшения нагрузки на базу данных используется библиотека Caffeine - высокопроизводительная библиотека кеширования в памяти:

- Настройка различных политик вытеснения кеша
- Определение максимального размера кеша
- Настройка времени жизни элементов кеша
- Асинхронная загрузка кеша
- Мониторинг метрик кеширования (попадания, промахи, вытеснения)

Основные кеши в приложении:
- userCache - кеширование данных пользователей
- pinCache - кеширование популярных пинов
- boardCache - кеширование досок
- searchCache - кеширование результатов популярных поисковых запросов
- configCache - кеширование конфигурационных данных

2.7.3 Prometheus и Grafana

Для визуализации метрик и мониторинга производительности в реальном времени используются:

- Prometheus - для сбора и хранения метрик
- Grafana - для создания интерактивных дашбордов и визуализации данных

Основные метрики, отслеживаемые системой мониторинга:
- Время отклика API-запросов
- Количество запросов в секунду
- Использование ресурсов (ЦП, память, диск)
- Количество активных пользователей
- Количество ошибок и исключений
- Производительность базы данных
- Использование кеша
- Задержки асинхронных операций 3 СТРУКТУРА ПРОГРАММНОГО КОМПЛЕКСА

3.1 Модульная организация серверной части

Серверная часть приложения построена на основе модульной архитектуры, что обеспечивает высокую степень изолированности компонентов, возможность их независимого развития и тестирования, а также упрощает сопровождение и расширение функциональности системы.

3.1.1 Принципы модульной организации

При проектировании архитектуры были применены следующие принципы:

1. Принцип единственной ответственности (Single Responsibility Principle)
Каждый модуль отвечает за решение строго определенной задачи, что упрощает понимание кода и снижает вероятность внесения ошибок при его модификации.

2. Принцип открытости/закрытости (Open/Closed Principle)
Архитектура позволяет расширять функциональность без изменения существующего кода, что обеспечивается через использование интерфейсов, абстракций и механизмов внедрения зависимостей.

3. Принцип подстановки Лисков (Liskov Substitution Principle)
Модули разработаны таким образом, чтобы объекты базовых классов могли быть заменены объектами их подклассов без изменения корректности программы.

4. Принцип разделения интерфейсов (Interface Segregation Principle)
Разработаны специализированные, "тонкие" интерфейсы, что позволяет клиентам зависеть только от тех методов, которые они используют.

5. Принцип инверсии зависимостей (Dependency Inversion Principle)
Модули высокого уровня не зависят от модулей низкого уровня, а оба типа модулей зависят от абстракций, что обеспечивается через систему внедрения зависимостей Spring.

3.1.2 Организация пакетов

Исходный код приложения организован в иерархическую структуру пакетов, отражающую функциональное назначение компонентов:

com.example.server
  ├── PinterestApplication.java (точка входа в приложение)
  └── UsPinterest
      ├── config (конфигурационные классы)
      │   ├── SecurityConfig.java
      │   ├── WebConfig.java
      │   ├── DataSourceConfig.java
      │   ├── RabbitMQConfig.java
      │   └── ...
      │
      ├── controller (контроллеры REST API)
      │   ├── AuthController.java
      │   ├── PinController.java
      │   ├── UserController.java
      │   └── ...
      │
      ├── service (сервисы бизнес-логики)
      │   ├── PinService.java
      │   ├── UserService.java
      │   ├── FileStorageService.java
      │   └── ...
      │
      ├── repository (репозитории для доступа к данным)
      │   ├── PinRepository.java
      │   ├── UserRepository.java
      │   ├── BoardRepository.java
      │   └── ...
      │
      ├── model (модели данных)
      │   ├── User.java
      │   ├── Pin.java
      │   ├── Board.java
      │   └── ...
      │
      ├── entity (сущности для данных, не попадающих в основные модели)
      │   ├── Comment.java
      │   ├── Like.java
      │   ├── Feedback.java
      │   └── ...
      │
      ├── dto (объекты передачи данных)
      │   ├── PinResponse.java
      │   ├── UserDto.java
      │   ├── LoginRequest.java
      │   └── ...
      │
      ├── security (компоненты безопасности)
      │   ├── JwtTokenProvider.java
      │   ├── JwtAuthenticationFilter.java
      │   ├── UserPrincipal.java
      │   └── ...
      │
      ├── exception (исключения и их обработчики)
      │   ├── ResourceNotFoundException.java
      │   ├── BadRequestException.java
      │   ├── GlobalExceptionHandler.java
      │   └── ...
      │
      ├── event (классы для работы с событиями)
      │   ├── NotificationEvent.java
      │   ├── UserActivityEvent.java
      │   └── ...
      │
      ├── util (утилитарные классы)
      │   ├── FileUtil.java
      │   ├── ValidationUtil.java
      │   ├── SecurityUtil.java
      │   └── ...
      │
      └── validation (валидаторы)
          ├── EmailValidator.java
          ├── PasswordValidator.java
          └── ...

3.1.3 Взаимодействие между модулями

Взаимодействие между модулями организовано в соответствии с принципами многоуровневой архитектуры и осуществляется через четко определенные интерфейсы:

1. Контроллеры получают HTTP-запросы, извлекают и валидируют параметры запросов, делегируют обработку соответствующим сервисам и формируют HTTP-ответы.

2. Сервисы реализуют бизнес-логику, используя данные, предоставленные контроллерами, взаимодействуют с репозиториями для доступа к данным и вызывают другие сервисы при необходимости.

3. Репозитории обеспечивают абстракцию над источником данных (базой данных), предоставляя методы для выполнения операций CRUD и сложных запросов.

4. Модели данных представляют собой сущности предметной области, которые используются на всех уровнях приложения.

5. DTO (Data Transfer Objects) используются для передачи данных между контроллерами и клиентами, а также между различными слоями приложения, когда требуется специфическое представление данных.

Для управления зависимостями и организации взаимодействия между компонентами используется механизм внедрения зависимостей (Dependency Injection) Spring Framework. Это позволяет:

- Уменьшить связанность между компонентами
- Упростить тестирование путем подмены реальных реализаций моками
- Централизованно управлять жизненным циклом объектов
- Переключаться между различными реализациями в зависимости от окружения

3.2 Модели данных

Модели данных являются основой приложения, определяя структуру информации, с которой работает система. В приложении используется набор взаимосвязанных моделей, которые отражают различные аспекты предметной области.

3.2.1 Основные модели

1. User (Пользователь)
Модель представляет пользователя системы и содержит следующие основные атрибуты:

```java
@Entity
@Table(name = "users")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    private String fullName;
    
    private String bio;
    
    private String avatarUrl;
    
    @Column(nullable = false)
    private boolean enabled;
    
    @Enumerated(EnumType.STRING)
    private Role role;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Board> boards = new HashSet<>();
    
    @OneToMany(mappedBy = "follower", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Follow> following = new HashSet<>();
    
    @OneToMany(mappedBy = "following", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Follow> followers = new HashSet<>();
    
    // Другие поля и методы
}
```

2. Pin (Пин)
Модель представляет основной контент приложения - изображения с метаданными:

```java
@Entity
@Table(name = "pins")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Pin {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "picture_id")
    private Picture picture;
    
    @ElementCollection
    @CollectionTable(name = "pin_tags", joinColumns = @JoinColumn(name = "pin_id"))
    private Set<String> tags = new HashSet<>();
    
    @ManyToMany
    @JoinTable(
        name = "pin_board",
        joinColumns = @JoinColumn(name = "pin_id"),
        inverseJoinColumns = @JoinColumn(name = "board_id")
    )
    private Set<Board> boards = new HashSet<>();
    
    @OneToMany(mappedBy = "pin", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> comments = new ArrayList<>();
    
    @OneToMany(mappedBy = "pin", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Like> likes = new HashSet<>();
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "location_id")
    private Location location;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // Другие поля и методы
}
```

3. Picture (Изображение)
Модель хранит детальную информацию об изображении:

```java
@Entity
@Table(name = "pictures")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Picture {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String originalUrl;
    
    private String thumbnailUrl;
    
    private String fullHdUrl;
    
    private String webpUrl;
    
    private Integer width;
    
    private Integer height;
    
    private String contentType;
    
    private Long fileSize;
    
    @Column(columnDefinition = "jsonb")
    private String metadata;
    
    @Column(length = 50)
    private String dominantColor;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    // Другие поля и методы
}
```

4. Board (Доска)
Модель представляет коллекцию пинов, созданную пользователем:

```java
@Entity
@Table(name = "boards")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Board {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @ManyToMany(mappedBy = "boards")
    private Set<Pin> pins = new HashSet<>();
    
    @Column(nullable = false)
    private boolean isPrivate = false;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // Другие поля и методы
}
```

3.2.2 Вспомогательные модели

1. Follow (Подписка)
Модель представляет отношения подписки между пользователями:

```java
@Entity
@Table(name = "follows")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Follow {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "follower_id", nullable = false)
    private User follower;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "following_id", nullable = false)
    private User following;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

2. Comment (Комментарий)
Модель представляет комментарии, оставленные пользователями к пинам:

```java
@Entity
@Table(name = "comments")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 1000)
    private String content;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pin_id", nullable = false)
    private Pin pin;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private Comment parent;
    
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> replies = new ArrayList<>();
    
    @OneToMany(mappedBy = "comment", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Like> likes = new HashSet<>();
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

3. Like (Лайк)
Модель представляет оценку "нравится", оставленную пользователем:

```java
@Entity
@Table(name = "likes")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Like {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pin_id")
    private Pin pin;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "comment_id")
    private Comment comment;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

4. Post (Пост)
Модель представляет публикацию пользователя, которая может содержать текст и изображения:

```java
@Entity
@Table(name = "posts")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String content;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "post_id")
    private List<Photo> photos = new ArrayList<>();
    
    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Like> likes = new HashSet<>();
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

5. Location (Местоположение)
Модель хранит географические данные для привязки пинов к местоположениям:

```java
@Entity
@Table(name = "locations")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Location {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    private String address;
    
    private Double latitude;
    
    private Double longitude;
    
    private String city;
    
    private String country;
    
    @Column(columnDefinition = "jsonb")
    private String additionalInfo;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

3.2.3 Служебные модели

1. Notification (Уведомление)
Модель представляет уведомление для пользователя о различных событиях:

```java
@Entity
@Table(name = "notifications")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String content;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationType type;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "actor_id")
    private User actor;
    
    @Column(nullable = false)
    private boolean read = false;
    
    @Column(columnDefinition = "jsonb")
    private String data;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

2. RefreshToken (Токен обновления)
Модель хранит токены для обновления JWT токенов доступа:

```java
@Entity
@Table(name = "refresh_tokens")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String token;
    
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false)
    private LocalDateTime expiryDate;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

3. VerificationToken (Токен верификации)
Модель хранит токены для верификации email пользователей:

```java
@Entity
@Table(name = "verification_tokens")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class VerificationToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String token;
    
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false)
    private LocalDateTime expiryDate;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

4. FcmToken (Токен Firebase Cloud Messaging)
Модель хранит токены устройств для отправки push-уведомлений:

```java
@Entity
@Table(name = "fcm_tokens")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FcmToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String token;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    private String deviceInfo;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

5. Feedback (Обратная связь)
Модель хранит отзывы и предложения пользователей:

```java
@Entity
@Table(name = "feedback")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Feedback {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 2000)
    private String content;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private FeedbackType type;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
    
    private String contactInfo;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

3.2.4 Отношения между моделями

В системе реализованы различные типы отношений между моделями:

1. Один ко многим (One-to-Many):
- User -> Board: один пользователь может иметь много досок
- User -> Pin: один пользователь может создать много пинов
- Pin -> Comment: один пин может иметь много комментариев
- User -> Notification: один пользователь может получать много уведомлений

2. Многие ко многим (Many-to-Many):
- Pin <-> Board: пин может быть добавлен на несколько досок, и доска может содержать несколько пинов
- User <-> User (через Follow): пользователь может подписываться на многих пользователей и иметь много подписчиков

3. Один к одному (One-to-One):
- Pin -> Picture: каждый пин связан с одним изображением
- User -> RefreshToken: каждый пользователь имеет один токен обновления
- User -> VerificationToken: каждый пользователь имеет один токен верификации

4. Самореференсные связи:
- Comment -> Comment: комментарии могут иметь вложенные комментарии (ответы)

Для оптимизации производительности и соблюдения принципов проектирования:
- Используется ленивая загрузка (FetchType.LAZY) для предотвращения излишней загрузки связанных сущностей
- Применяется каскадное сохранение и удаление (CascadeType.ALL) для автоматического управления связанными сущностями
- Используются двунаправленные связи для удобства навигации по объектной модели
- Применяется orphanRemoval = true для автоматического удаления осиротевших связанных объектов

3.3 Контроллеры и API

Контроллеры являются точкой входа в приложение и отвечают за обработку HTTP-запросов, маршрутизацию и формирование ответов. Разработанный сервер предоставляет RESTful API, который обеспечивает взаимодействие с клиентскими приложениями.

3.3.1 Основные принципы проектирования API

При разработке API были соблюдены следующие принципы:

1. RESTful архитектура:
- Использование HTTP методов (GET, POST, PUT, DELETE) в соответствии с их семантикой
- Ресурсно-ориентированная структура эндпоинтов
- Использование статус-кодов HTTP для индикации результатов операций
- Применение стандартных заголовков HTTP

2. Версионирование API:
- Использование префикса "/api/v1" для обеспечения возможности развития API без нарушения обратной совместимости

3. Согласованное именование ресурсов:
- Использование существительных во множественном числе для ресурсов (/pins, /users, /boards)
- Использование вложенных ресурсов для выражения отношений (/users/{id}/pins)

4. Пагинация и фильтрация:
- Поддержка параметров пагинации (page, size) для ограничения размера выборки
- Поддержка курсорной пагинации для эффективной работы с большими наборами данных
- Параметры фильтрации для кастомизации выборки

5. Формат запросов и ответов:
- Использование JSON как основного формата данных
- Стандартизированная структура ответов с полями для данных, метаданных и ошибок
- Поддержка HATEOAS для создания самодокументируемого API

3.3.2 Контроллеры управления пользователями

1. AuthController
Отвечает за аутентификацию и управление доступом пользователей:

```java
@RestController
@RequestMapping("/api/v1/auth")
@Tag(name = "Authentication", description = "API для аутентификации и управления доступом")
public class AuthController {
    private final UserService userService;
    private final RefreshTokenService refreshTokenService;
    
    @PostMapping("/login")
    public ResponseEntity<TokenRefreshResponse> login(@Valid @RequestBody LoginRequest request) {
        // Логика аутентификации
    }
    
    @PostMapping("/register")
    public ResponseEntity<MessageResponse> register(@Valid @RequestBody RegisterRequest request) {
        // Логика регистрации
    }
    
    @PostMapping("/refresh")
    public ResponseEntity<TokenRefreshResponse> refreshToken(@Valid @RequestBody TokenRefreshRequest request) {
        // Логика обновления токена
    }
    
    @PostMapping("/logout")
    public ResponseEntity<MessageResponse> logout() {
        // Логика выхода
    }
    
    @GetMapping("/verify")
    public ResponseEntity<MessageResponse> verifyAccount(@RequestParam String token) {
        // Логика верификации аккаунта
    }
    
    @PostMapping("/password/reset")
    public ResponseEntity<MessageResponse> resetPassword(@Valid @RequestBody PasswordResetRequest request) {
        // Логика сброса пароля
    }
}
```

2. UserController
Обеспечивает операции с пользователями:

```java
@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Users", description = "API для управления пользователями")
public class UserController {
    private final UserService userService;
    
    @GetMapping
    public ResponseEntity<PageResponse<ProfileResponse>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String query) {
        // Логика получения списка пользователей
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ProfileResponse> getUser(@PathVariable Long id) {
        // Логика получения данных пользователя
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('USER') and @securityUtils.isCurrentUser(#id)")
    public ResponseEntity<ProfileResponse> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody EditProfileRequest request) {
        // Логика обновления данных пользователя
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @securityUtils.isCurrentUser(#id)")
    public ResponseEntity<MessageResponse> deleteUser(@PathVariable Long id) {
        // Логика удаления пользователя
    }
    
    @GetMapping("/{id}/pins")
    public ResponseEntity<PageResponse<PinThumbnailResponse>> getUserPins(
            @PathVariable Long id,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "12") int size) {
        // Логика получения пинов пользователя
    }
    
    @GetMapping("/{id}/boards")
    public ResponseEntity<PageResponse<BoardResponse>> getUserBoards(
            @PathVariable Long id,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "12") int size) {
        // Логика получения досок пользователя
    }
}
```

3. ProfileController
Обеспечивает операции с профилем текущего пользователя:

```java
@RestController
@RequestMapping("/api/v1/profile")
@Tag(name = "Profile", description = "API для управления профилем текущего пользователя")
@PreAuthorize("hasRole('USER')")
public class ProfileController {
    private final UserService userService;
    private final FileStorageService fileStorageService;
    
    @GetMapping
    public ResponseEntity<ProfileResponse> getCurrentProfile() {
        // Логика получения профиля текущего пользователя
    }
    
    @PutMapping
    public ResponseEntity<ProfileResponse> updateProfile(@Valid @RequestBody EditProfileRequest request) {
        // Логика обновления профиля
    }
    
    @PostMapping("/avatar")
    public ResponseEntity<ProfileResponse> updateAvatar(@RequestParam("file") MultipartFile file) {
        // Логика обновления аватара
    }
    
    @DeleteMapping("/avatar")
    public ResponseEntity<ProfileResponse> deleteAvatar() {
        // Логика удаления аватара
    }
    
    @PutMapping("/password")
    public ResponseEntity<MessageResponse> changePassword(@Valid @RequestBody ChangePasswordRequest request) {
        // Логика изменения пароля
    }
    
    @GetMapping("/pins")
    public ResponseEntity<PageResponse<PinThumbnailResponse>> getMyPins(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "12") int size) {
        // Логика получения пинов текущего пользователя
    }
    
    @GetMapping("/boards")
    public ResponseEntity<PageResponse<BoardResponse>> getMyBoards(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "12") int size) {
        // Логика получения досок текущего пользователя
    }
    
    @GetMapping("/notifications")
    public ResponseEntity<PageResponse<NotificationResponse>> getMyNotifications(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        // Логика получения уведомлений текущего пользователя
    }
} 